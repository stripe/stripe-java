// Generated by com.stripe.generator.entity.SdkBuilder

package com.stripe.model;

import com.stripe.Stripe;
import com.stripe.exception.StripeException;
import com.stripe.net.ApiResource;
import com.stripe.net.RequestOptions;
import java.math.BigDecimal;
import java.util.Map;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@EqualsAndHashCode(callSuper = false)
public class Subscription extends ApiResource implements HasId, MetadataStore<Subscription> {
  /**
   * A non-negative decimal between 0 and 100, with at most two decimal places. This represents the
   * percentage of the subscription invoice subtotal that will be transferred to the application
   * owner's Stripe account.
   */
  BigDecimal applicationFeePercent;

  /**
   * Either `charge_automatically`, or `send_invoice`. When charging automatically, Stripe will
   * attempt to pay this subscription at the end of the cycle using the default source attached to
   * the customer. When sending an invoice, Stripe will email your customer an invoice with payment
   * instructions.
   */
  String billing;

  /**
   * Determines the date of the first full invoice, and, for plans with `month` or `year` intervals,
   * the day of the month for subsequent invoices.
   */
  Long billingCycleAnchor;

  /**
   * Define thresholds at which an invoice will be sent, and the subscription advanced to a new
   * billing period.
   */
  BillingThresholds billingThresholds;

  /**
   * If the subscription has been canceled with the `at_period_end` flag set to `true`,
   * `cancel_at_period_end` on the subscription will be true. You can use this attribute to
   * determine whether a subscription that has a status of active is scheduled to be canceled at the
   * end of the current period.
   */
  Boolean cancelAtPeriodEnd;

  /**
   * If the subscription has been canceled, the date of that cancellation. If the subscription was
   * canceled with `cancel_at_period_end`, `canceled_at` will still reflect the date of the initial
   * cancellation request, not the end of the subscription period when the subscription is
   * automatically moved to a canceled state.
   */
  Long canceledAt;

  /** Time at which the object was created. Measured in seconds since the Unix epoch. */
  Long created;

  /**
   * End of the current period that the subscription has been invoiced for. At the end of this
   * period, a new invoice will be created.
   */
  Long currentPeriodEnd;

  /** Start of the current period that the subscription has been invoiced for. */
  Long currentPeriodStart;

  /** ID of the customer who owns the subscription. */
  @Getter(lombok.AccessLevel.NONE)
  @Setter(lombok.AccessLevel.NONE)
  ExpandableField<Customer> customer;

  /**
   * Number of days a customer has to pay invoices generated by this subscription. This value will
   * be `null` for subscriptions where `billing=charge_automatically`.
   */
  Long daysUntilDue;

  /**
   * ID of the default payment source for the subscription. It must belong to the customer
   * associated with the subscription and be in a chargeable state. If not set, defaults to the
   * customer's default source.
   */
  @Getter(lombok.AccessLevel.NONE)
  @Setter(lombok.AccessLevel.NONE)
  ExpandableField<PaymentSource> defaultSource;

  /**
   * Describes the current discount applied to this subscription, if there is one. When billing, a
   * discount applied to a subscription overrides a discount applied on a customer-wide basis.
   */
  Discount discount;

  /** If the subscription has ended, the date the subscription ended. */
  Long endedAt;

  /** Unique identifier for the object. */
  @Getter(onMethod = @__({@Override}))
  String id;

  /** List of subscription items, each with an attached plan. */
  SubscriptionItemCollection items;

  /**
   * Has the value `true` if the object exists in live mode or the value `false` if the object
   * exists in test mode.
   */
  Boolean livemode;

  /**
   * Set of key-value pairs that you can attach to an object. This can be useful for storing
   * additional information about the object in a structured format.
   */
  @Getter(onMethod = @__({@Override}))
  Map<String, String> metadata;

  /** String representing the object's type. Objects of the same type share the same value. */
  String object;

  /**
   * Hash describing the plan the customer is subscribed to. Only set if the subscription contains a
   * single plan.
   */
  Plan plan;

  /**
   * The quantity of the plan to which the customer is subscribed. For example, if your plan is
   * $10/user/month, and your customer has 5 users, you could pass 5 as the quantity to have the
   * customer charged $50 (5 x $10) monthly. Only set if the subscription contains a single plan.
   */
  Long quantity;

  /** Date the most recent update to this subscription started. */
  Long start;

  /**
   * Possible values are `trialing`, `active`, `past_due`, `canceled`, or `unpaid`. A subscription
   * still in its trial period is `trialing` and moves to `active` when the trial period is over. If
   * subscription `billing=charge_automatically` it becomes `past_due` when payment to renew it
   * fails and `canceled` or `unpaid` (depending on your subscriptions settings) when Stripe has
   * exhausted all payment retry attempts. If subscription `billing=send_invoice` it becomes
   * `past_due` when its invoice is not paid by the due date, and `canceled` or `unpaid` if it is
   * still not paid by an additional deadline after that. Note that when a subscription has a status
   * of `unpaid`, no subsequent invoices will be attempted (invoices will be created, but then
   * immediately automatically closed.) After receiving updated payment information from a customer,
   * you may choose to reopen and pay their closed invoices.
   */
  String status;

  /**
   * If provided, each invoice created by this subscription will apply the tax rate, increasing the
   * amount billed to the customer.
   */
  BigDecimal taxPercent;

  /** If the subscription has a trial, the end of that trial. */
  Long trialEnd;

  /** If the subscription has a trial, the beginning of that trial. */
  Long trialStart;

  /** Get id of expandable `customer` object. */
  public String getCustomer() {
    return (this.customer != null) ? this.customer.getId() : null;
  }

  public void setCustomer(String id) {
    this.customer = ApiResource.setExpandableFieldId(id, this.customer);
  }

  /** Get expanded `customer`. */
  public Customer getCustomerObject() {
    return (this.customer != null) ? this.customer.getExpanded() : null;
  }

  public void setCustomerObject(Customer expandableObject) {
    this.customer = new ExpandableField<Customer>(expandableObject.getId(), expandableObject);
  }

  /** Get id of expandable `defaultSource` object. */
  public String getDefaultSource() {
    return (this.defaultSource != null) ? this.defaultSource.getId() : null;
  }

  public void setDefaultSource(String id) {
    this.defaultSource = ApiResource.setExpandableFieldId(id, this.defaultSource);
  }

  /** Get expanded `defaultSource`. */
  public PaymentSource getDefaultSourceObject() {
    return (this.defaultSource != null) ? this.defaultSource.getExpanded() : null;
  }

  public void setDefaultSourceObject(PaymentSource expandableObject) {
    this.defaultSource =
        new ExpandableField<PaymentSource>(expandableObject.getId(), expandableObject);
  }

  /**
   * By default, returns a list of subscriptions that have not been canceled. In order to list
   * canceled subscriptions, specify <code>status=canceled</code>.
   */
  public static SubscriptionCollection list(Map<String, Object> params) throws StripeException {
    return list(params, (RequestOptions) null);
  }

  /**
   * By default, returns a list of subscriptions that have not been canceled. In order to list
   * canceled subscriptions, specify <code>status=canceled</code>.
   */
  public static SubscriptionCollection list(Map<String, Object> params, RequestOptions options)
      throws StripeException {
    String url = String.format("%s%s", Stripe.getApiBase(), "/v1/subscriptions");
    return requestCollection(url, params, SubscriptionCollection.class, options);
  }

  /** Creates a new subscription on an existing customer. */
  public static Subscription create(Map<String, Object> params) throws StripeException {
    return create(params, (RequestOptions) null);
  }

  /** Creates a new subscription on an existing customer. */
  public static Subscription create(Map<String, Object> params, RequestOptions options)
      throws StripeException {
    String url = String.format("%s%s", Stripe.getApiBase(), "/v1/subscriptions");
    return request(ApiResource.RequestMethod.POST, url, params, Subscription.class, options);
  }

  /**
   * Updates an existing subscription on a customer to match the specified parameters. When changing
   * plans or quantities, we will optionally prorate the price we charge next month to make up for
   * any price changes. To preview how the proration will be calculated, use the <a
   * href="#upcoming_invoice">upcoming invoice</a> endpoint.
   */
  public Subscription update(Map<String, Object> params) throws StripeException {
    return update(params, (RequestOptions) null);
  }

  /**
   * Updates an existing subscription on a customer to match the specified parameters. When changing
   * plans or quantities, we will optionally prorate the price we charge next month to make up for
   * any price changes. To preview how the proration will be calculated, use the <a
   * href="#upcoming_invoice">upcoming invoice</a> endpoint.
   */
  public Subscription update(Map<String, Object> params, RequestOptions options)
      throws StripeException {
    String url =
        String.format(
            "%s%s", Stripe.getApiBase(), String.format("/v1/subscriptions/%s", this.getId()));
    return request(ApiResource.RequestMethod.POST, url, params, Subscription.class, options);
  }

  /** Retrieves the subscription with the given ID. */
  public static Subscription retrieve(String subscriptionExposedId) throws StripeException {
    return retrieve(subscriptionExposedId, (Map<String, Object>) null, (RequestOptions) null);
  }

  /** Retrieves the subscription with the given ID. */
  public static Subscription retrieve(String subscriptionExposedId, RequestOptions options)
      throws StripeException {
    return retrieve(subscriptionExposedId, (Map<String, Object>) null, options);
  }

  /** Retrieves the subscription with the given ID. */
  public static Subscription retrieve(
      String subscriptionExposedId, Map<String, Object> params, RequestOptions options)
      throws StripeException {
    String url =
        String.format(
            "%s%s",
            Stripe.getApiBase(), String.format("/v1/subscriptions/%s", subscriptionExposedId));
    return request(ApiResource.RequestMethod.GET, url, params, Subscription.class, options);
  }

  /**
   * Cancels a customer’s subscription immediately. The customer will not be charged again for the
   * subscription.
   *
   * <p>Note, however, that any pending invoice items that you’ve created will still be charged for
   * at the end of the period, unless manually <a href="#delete_invoiceitem">deleted</a>. If you’ve
   * set the subscription to cancel at the end of the period, any pending prorations will also be
   * left in place and collected at the end of the period. But if the subscription is set to cancel
   * immediately, pending prorations will be removed.
   *
   * <p>By default, upon subscription cancellation, Stripe will close all unpaid invoices for the
   * customer. This is designed to prevent unexpected payment attempts after the customer has
   * canceled a subscription. However, you can reopen the invoices manually after subscription
   * cancellation to have us proceed with payment collection. Or, you could even re-attempt payment
   * yourself on all unpaid invoices before allowing the customer to cancel the subscription at all.
   */
  public Subscription cancel() throws StripeException {
    return cancel((Map<String, Object>) null, (RequestOptions) null);
  }

  /**
   * Cancels a customer’s subscription immediately. The customer will not be charged again for the
   * subscription.
   *
   * <p>Note, however, that any pending invoice items that you’ve created will still be charged for
   * at the end of the period, unless manually <a href="#delete_invoiceitem">deleted</a>. If you’ve
   * set the subscription to cancel at the end of the period, any pending prorations will also be
   * left in place and collected at the end of the period. But if the subscription is set to cancel
   * immediately, pending prorations will be removed.
   *
   * <p>By default, upon subscription cancellation, Stripe will close all unpaid invoices for the
   * customer. This is designed to prevent unexpected payment attempts after the customer has
   * canceled a subscription. However, you can reopen the invoices manually after subscription
   * cancellation to have us proceed with payment collection. Or, you could even re-attempt payment
   * yourself on all unpaid invoices before allowing the customer to cancel the subscription at all.
   */
  public Subscription cancel(Map<String, Object> params) throws StripeException {
    return cancel(params, (RequestOptions) null);
  }

  /**
   * Cancels a customer’s subscription immediately. The customer will not be charged again for the
   * subscription.
   *
   * <p>Note, however, that any pending invoice items that you’ve created will still be charged for
   * at the end of the period, unless manually <a href="#delete_invoiceitem">deleted</a>. If you’ve
   * set the subscription to cancel at the end of the period, any pending prorations will also be
   * left in place and collected at the end of the period. But if the subscription is set to cancel
   * immediately, pending prorations will be removed.
   *
   * <p>By default, upon subscription cancellation, Stripe will close all unpaid invoices for the
   * customer. This is designed to prevent unexpected payment attempts after the customer has
   * canceled a subscription. However, you can reopen the invoices manually after subscription
   * cancellation to have us proceed with payment collection. Or, you could even re-attempt payment
   * yourself on all unpaid invoices before allowing the customer to cancel the subscription at all.
   */
  public Subscription cancel(Map<String, Object> params, RequestOptions options)
      throws StripeException {
    String url =
        String.format(
            "%s%s", Stripe.getApiBase(), String.format("/v1/subscriptions/%s", this.getId()));
    return request(ApiResource.RequestMethod.DELETE, url, params, Subscription.class, options);
  }

  /** Removes the currently applied discount on a subscription. */
  public Discount deleteDiscount() throws StripeException {
    return deleteDiscount((Map<String, Object>) null, (RequestOptions) null);
  }

  /** Removes the currently applied discount on a subscription. */
  public Discount deleteDiscount(Map<String, Object> params) throws StripeException {
    return deleteDiscount(params, (RequestOptions) null);
  }

  /** Removes the currently applied discount on a subscription. */
  public Discount deleteDiscount(Map<String, Object> params, RequestOptions options)
      throws StripeException {
    String url =
        String.format(
            "%s%s",
            Stripe.getApiBase(), String.format("/v1/subscriptions/%s/discount", this.getId()));
    return request(ApiResource.RequestMethod.DELETE, url, params, Discount.class, options);
  }

  @Getter
  @Setter
  @EqualsAndHashCode(callSuper = false)
  public static class BillingThresholds extends StripeObject {
    /** Monetary threshold that triggers the subscription to create an invoice. */
    Long amountGte;

    /**
     * Indicates if the `billing_cycle_anchor` should be reset when a threshold is reached. If true,
     * `billing_cycle_anchor` will be updated to the date/time the threshold was last reached;
     * otherwise, the value will remain unchanged. This value may not be `true` if the subscription
     * contains items with plans that have `aggregate_usage=last_ever`.
     */
    Boolean resetBillingCycleAnchor;
  }
}
